#include "parcels.h"
#include "../serial.h"
#include "../common/slots.h"
#include "../wifitime.h"
#include <esp_log.h>
#include "parcels.cfg.h"
#include <time.h>

static const char * TAG = "parcels";

namespace parcels {
	int16_t parcel_name_offsets[6]; // generated by cfg

	void set_parcel_name(size_t i, const char * value) {
		if (i == 0) {
			memset(parcel_name_offsets, 0, sizeof parcel_name_offsets);
			serial::interface.delete_slot(slots::PARCEL_NAMES);
		}
		parcel_name_offsets[i] = serial::interface.current_slot_size(slots::PARCEL_NAMES);
		serial::interface.allocate_slot_size(slots::PARCEL_NAMES, parcel_name_offsets[i] + strlen(value) + 1);
		serial::interface.update_slot_partial(slots::PARCEL_NAMES, parcel_name_offsets[i], value, strlen(value) + 1);
	}

	auto generate_strappender(slots::DataID did) {
		return [did, offset = (size_t)0] (const char * text) mutable {
			if (text == nullptr) {
				serial::interface.allocate_slot_size(did, offset);
				return offset;
			}
			size_t newend = offset + strlen(text) + 1;
			if (newend > serial::interface.current_slot_size(did)) serial::interface.allocate_slot_size(did, newend);
			serial::interface.update_slot_partial(did, offset, text, strlen(text) + 1, true, false);
			size_t result = offset;
			offset = newend;
			return result;
		};
	}

	uint64_t process_datetime(const char * timestring) {
		struct tm parsed;
		if (strptime(timestring, "%Y-%m-%dT%H:%M:%SZ", &parsed) == NULL) return 0;
		return wifi::millis_to_local(1000 * wifi::timegm(&parsed));
	}

	slots::ParcelInfo::StatusIcon get_icon_enum(const char * text) {return slots::ParcelInfo::UNK;}

	struct LocationBuf {
		const char * get() { return buf; }

		void push_country(const char * c) {
			if (has_country) return;
			has_country = true;
			if (!has_city) {
				strncpy(buf, c, 64);
			}
			else {
				// append
				int end = strlen(buf);
				snprintf(buf + end, 64 - end, ", %s", c);
			}
		}

		void push_city(const char * c) {
			if (has_city) return;
			has_city = true;
			if (!has_country) {
				strncpy(buf, c, 64);
			}
			else {
				char buf2[64]; strncpy(buf2, buf, 64);
				snprintf(buf, 64, "%s, %s", c, buf2);
			}
		}

		operator bool() {return has_city || has_country;}

	private:
		char buf[64]{};
		bool has_city = false, has_country = false;
	};

	void init() {}
	bool loop() {
		if (!parcels_api_key) return true;

		// TEST DATA TEST DATA THATS RIGHT ITS THE TEST DATA

		serial::interface.delete_slot(slots::PARCEL_INFOS);
		serial::interface.delete_slot(slots::PARCEL_EXTRA_INFOS);

		auto append_shortheap = generate_strappender(slots::PARCEL_STATUS_SHORT);
		int i = -1;

		int n_parcels = 0, n_infolines = 0;

		slots::ParcelInfo pis[6];
		char auth[96];

		snprintf(auth, 96, "Bearer %s", parcels_api_key);
		const char * headers[][2] = {
			{"Authorization", auth},
			{NULL, NULL}
		};

		for (const auto& cfg : tracker_configs) {
			i += 1;
			if (!cfg.enabled) continue;

			slots::ParcelInfo &pi = pis[n_parcels++];
			char url[128];
			LocationBuf last_seen_location;
			char * last_seen_status_line = nullptr;

			// get url
			snprintf(url, 128, "/v2/trackers/%s", cfg.tracker_id);
			auto dw = dwhttp::download_with_callback("_api.easypost.com", url, headers);
			dw.make_nonclose();

			if (!dw.ok()) {
				ESP_LOGW(TAG, "Failed to request tracker %s", cfg.tracker_id);
				continue;
			}

			pi.status.flags = 0;
			pi.name_offset = parcel_name_offsets[i]; // load name from globals
			pi.status_icon = slots::ParcelInfo::UNK;

			int last_index = -1;
			
			json::JSONParser p_parser([&](json::PathNode ** stack, uint8_t stack_ptr, const json::Value& v){
				if (stack_ptr == 2) {
					// Update the status icon if it's not already set
					if (strcmp(stack[1]->name, "status") == 0 && v.type == v.STR && (pi.status_icon != slots::ParcelInfo::UNK)) {
						pi.status_icon = get_icon_enum(v.str_val);
					}
					else if (strcmp(stack[1]->name, "updated_at") == 0 && v.type == v.STR && !(pi.status.flags & pi.status.HAS_UPDATED_TIME)) {
						pi.status.flags |= pi.status.HAS_UPDATED_TIME;
						pi.updated_time = process_datetime(v.str_val);
					}
					else if (strcmp(stack[1]->name, "est_delivery_date") == 0 && v.type == v.STR) {
						pi.status.flags |= pi.status.HAS_EST_DEILIVERY;
						pi.estimated_delivery = process_datetime(v.str_val);
					}
				}
				else if (stack_ptr >= 3 && strcmp(stack[1]->name, "tracking_details") == 0 && stack[1]->is_array()) {
					if (last_index != stack[1]->index) {
						last_index = stack[1]->index;
						new (&last_seen_location) LocationBuf{};
					}
					// Grab the latest message
					if (strcmp(stack[2]->name, "message") == 0 && v.type == v.STR) {
						if (last_seen_status_line) free(last_seen_status_line);
						pi.status.flags |= pi.status.HAS_STATUS;
						last_seen_status_line = strdup(v.str_val);
					}
					else if (strcmp(stack[2]->name, "status") == 0 && v.type == v.STR && strcmp(v.str_val, "unknown")) {
						pi.status_icon = get_icon_enum(v.str_val);
					}
					else if (strcmp(stack[2]->name, "datetime") == 0 && v.type == v.STR) {
						pi.status.flags |= pi.status.HAS_UPDATED_TIME;
						pi.updated_time = process_datetime(v.str_val);
					}

					// process location: 
					else if (stack_ptr == 4 && strcmp(stack[2]->name, "tracking_location") == 0) {
						if (strcmp(stack[3]->name, "city") == 0 && v.type == v.STR) {
							last_seen_location.push_city(v.str_val);
						}
						else if (strcmp(stack[3]->name, "country") == 0 && v.type == v.STR) {
							last_seen_location.push_country(v.str_val);
						}
					}
				}
			});

			if (!p_parser.parse(dw)) {
				ESP_LOGD(TAG, "json parse failed");
				return false;
			}

			// parse finished: fill in offsets
			if (last_seen_location) {
				pi.status.location_offset = append_shortheap(last_seen_location.get());
				pi.status.flags |= pi.status.HAS_LOCATION;
			}
			if (last_seen_status_line) {
				pi.status.status_offset = append_shortheap(last_seen_status_line);
				free(last_seen_status_line);
				pi.status.flags |= pi.status.HAS_STATUS;
			}
		}

		dwhttp::close_connection(true);

		if (n_parcels) {
			append_shortheap(nullptr); // truncate
			serial::interface.trigger_slot_update(slots::PARCEL_STATUS_SHORT);
			serial::interface.update_slot_raw(slots::PARCEL_INFOS, &pis, sizeof(slots::ParcelInfo) * n_parcels);
		}

		return true;
	}
}
