#include "parcels.h"
#include "../serial.h"
#include "../common/slots.h"
#include "sccfg.h"
#include "../wifitime.h"
#include <esp_log.h>
#include "parcels.cfg.h"
#include <memory>
#include <time.h>

static const char * TAG = "parcels";

namespace parcels {
	int16_t parcel_name_offsets[6]; // generated by cfg
	
	struct NewParcelParams {
		char *code, *carrier; // malloced (freed by us)
		char *result{}; // malloced (freed by them)
		bool is_error_message = false;
		TaskHandle_t task_waiting_for_new_parcel_id;
	} *npp;

	void set_parcel_name(size_t i, const char * value) {
		if (i == 0) {
			memset(parcel_name_offsets, 0, sizeof parcel_name_offsets);
			serial::interface.delete_slot(slots::PARCEL_NAMES);
		}
		parcel_name_offsets[i] = serial::interface.current_slot_size(slots::PARCEL_NAMES);
		serial::interface.allocate_slot_size(slots::PARCEL_NAMES, parcel_name_offsets[i] + strlen(value) + 1);
		serial::interface.update_slot_partial(slots::PARCEL_NAMES, parcel_name_offsets[i], value, strlen(value) + 1);
	}

	auto generate_strappender(slots::DataID did) {
		return [did, offset = (size_t)0] (const char * text) mutable {
			if (text == nullptr) {
				serial::interface.allocate_slot_size(did, offset);
				serial::interface.trigger_slot_update(did);
				return offset;
			}
			size_t newend = offset + strlen(text) + 1;
			if (newend > serial::interface.current_slot_size(did)) serial::interface.allocate_slot_size(did, newend);
			serial::interface.update_slot_partial(did, offset, text, strlen(text) + 1, true, false);
			size_t result = offset;
			offset = newend;
			return result;
		};
	}

	uint64_t process_datetime(const char * timestring) {
		struct tm parsed{};
		auto comp = sscanf(timestring, "%d-%d-%dT%d:%d:%dZ", &parsed.tm_year, &parsed.tm_mon, &parsed.tm_mday, &parsed.tm_hour, &parsed.tm_min, &parsed.tm_sec);
		ESP_LOGD(TAG, "parse %s with %d", timestring, comp);
		parsed.tm_mon -= 1;
		parsed.tm_year -= 1900;
		return wifi::millis_to_local(1000 * (uint64_t)wifi::timegm(&parsed));
	}

	slots::ParcelInfo::StatusIcon get_icon_enum(const char * text) {
		if (!strcmp(text, "pre_transit")) return slots::ParcelInfo::PRE_TRANSIT;
		else if (!strcmp(text, "in_transit")) return slots::ParcelInfo::IN_TRANSIT;
		else if (!strcmp(text, "out_for_delivery")) return slots::ParcelInfo::OUT_FOR_DELIVERY;
		else if (!strcmp(text, "delivered")) return slots::ParcelInfo::DELIVERED;
		else if (!strcmp(text, "available_for_pickup")) return slots::ParcelInfo::READY_FOR_PICKUP;
		else if (!strcmp(text, "failure")) return slots::ParcelInfo::FAILED_TO_DELIVER;
		else if (!strcmp(text, "cancelled")) return slots::ParcelInfo::CANCELLED;
		else if (!strcmp(text, "error")) return slots::ParcelInfo::GENERAL_ERROR;
		else if (!strcmp(text, "return_to_sender")) return slots::ParcelInfo::RETURN_TO_SENDER;
		return slots::ParcelInfo::UNK;
	}

	struct LocationBuf {
		const char * get() { return buf.get(); }

		void push_country(const char * c) {
			if (has_country) return;
			has_country = true;
			if (!has_city) {
				strncpy(buf.get(), c, 64);
			}
			else {
				// append
				int end = strlen(buf.get());
				snprintf(buf.get() + end, 64 - end, ", %s", c);
			}
		}

		void push_city(const char * c) {
			if (has_city) return;
			has_city = true;
			if (!has_country) {
				strncpy(buf.get(), c, 64);
			}
			else {
				char buf2[64]; strncpy(buf2, buf.get(), 64);
				snprintf(buf.get(), 64, "%s, %s", c, buf2);
			}
		}

		operator bool() {return has_city || has_country;}

		LocationBuf() {
			buf.reset(new char[64]{});
		}

	private:
		std::unique_ptr<char []> buf;
		bool has_city = false, has_country = false;
	};

	constexpr inline size_t max_single_entry_textcount = 480;

	void process_new_parcel_request(const char * headers[][2]) {
		headers[1][0] = "Content-Type";
		headers[1][1] = "application/json";
		// Construct request body
		char reqbody[128]; // this does in fact fit on the stack just fine
		if (npp->carrier) {
			snprintf(reqbody, 128, "{\"tracker\":{\"tracking_code\":\"%s\",\"carrier\":\"%s\"}}", npp->code, npp->carrier);
			free(npp->code); npp->code = nullptr;
			free(npp->carrier); npp->carrier = nullptr;
		}
		else {
			snprintf(reqbody, 128, "{\"tracker\":{\"tracking_code\":\"%s\"}}", npp->code);
			free(npp->code); npp->code = nullptr;
		}

		// Send request
		auto dw = dwhttp::download_with_callback("_api.easypost.com", "/v2/trackers", headers, "POST", reqbody);
		npp->is_error_message = false;
		npp->result = nullptr;
		if (!dw.ok()) {
			ESP_LOGE(TAG, "failed to create tracker: %d", dw.result_code());
			if (dw.result_code() >= 400) {
				// should contain a valid error
				json::JSONParser e_p([&](json::PathNode ** stack, uint8_t stack_ptr, const json::Value& v){
					if (stack_ptr == 3 && strcmp(stack[1]->name, "error") == 0 && strcmp(stack[2]->name, "message") == 0 && v.type == v.STR) {
						npp->is_error_message = true;
						if (npp->result) free(npp->result);
						npp->result = strdup(v.str_val);
					}
				});

				e_p.parse(dw);
			}
			return;
		}

		// Scan for tracker id
		json::JSONParser r_p([&](json::PathNode ** stack, uint8_t stack_ptr, const json::Value& v){
			if (stack_ptr == 2 && strcmp(stack[1]->name, "id") == 0 && v.type == v.STR && !npp->result) {
				// got result
				ESP_LOGI(TAG, "created tracker with id %s", v.str_val);
				npp->is_error_message = false;
				npp->result = strdup(v.str_val);
			}
		});
		
		r_p.parse(dw);
	}

	char * generate_tracker_id(char * tracker_code, char * tracker_carrier, bool& had_error) {
		// Setup npp
		NewParcelParams new_npp{};
		new_npp.code = tracker_code; new_npp.carrier = tracker_carrier;
		new_npp.task_waiting_for_new_parcel_id = xTaskGetCurrentTaskHandle();
		npp = &new_npp;
		// Wait
		grabber::refresh(slots::protocol::GrabberID::PARCELS);
		uint32_t discard;
		xTaskNotifyWait(0, 0, &discard, pdMS_TO_TICKS(20000));
		had_error = new_npp.is_error_message;
		return new_npp.result;
	}

	void init() {}
	bool loop() {
		if (!parcels_api_key) return true;

		std::unique_ptr<char[]> auth; auth.reset(new char[96]{});

		snprintf(auth.get(), 96, "Bearer %s", parcels_api_key.get());
		const char * headers[][2] = {
			{"Authorization", auth.get()},
			{NULL, NULL},
			{NULL, NULL},
		};

		if (npp) {
			// process new parcel
			process_new_parcel_request(headers);

			xTaskNotify(npp->task_waiting_for_new_parcel_id, 0xf, eNoAction);
			npp = nullptr;
			return true;
		}

		auto append_shortheap = generate_strappender(slots::PARCEL_STATUS_SHORT), append_longheap = generate_strappender(slots::PARCEL_STATUS_LONG);
		int i = -1;

		int n_parcels = 0;

		slots::ParcelInfo pis[6]{};
		int parcel_entry_lengths[6]{};
		bool parcel_oks[6]{};
		size_t parcel_entry_text_lens[6]{};

		bool encountered_error = false;
		std::unique_ptr<char[]> url; url.reset(new char[128]{});

		for (const auto& cfg : tracker_configs) {
			i += 1;
			if (!cfg.enabled) continue;

			// get url
			snprintf(url.get(), 128, "/v2/trackers/%s", cfg.tracker_id.get());
			auto dw = dwhttp::download_with_callback("_api.easypost.com", url.get(), headers);
			dw.make_nonclose();

			if (!dw.ok()) {
				ESP_LOGW(TAG, "Failed to request tracker %s", cfg.tracker_id.get());
				if (dw.result_code() == 404) {
					ESP_LOGI(TAG, "Disabling tracker...");
					cfg.enabled = false;
				}
				else encountered_error = true;
				continue;
			}

			slots::ParcelInfo &pi = pis[n_parcels++];
			LocationBuf last_seen_location;
			char * last_seen_status_line = nullptr;

			pi.status.flags = 0;
			pi.name_offset = parcel_name_offsets[i]; // load name from globals
			pi.status_icon = slots::ParcelInfo::UNK;

			int last_index = -1;
			
			json::JSONParser p_parser([&](json::PathNode ** stack, uint8_t stack_ptr, const json::Value& v){
				if (stack_ptr == 2) {
					// Update the status icon if it's not already set
					if (strcmp(stack[1]->name, "status") == 0 && v.type == v.STR && (pi.status_icon != slots::ParcelInfo::UNK)) {
						pi.status_icon = get_icon_enum(v.str_val);
					}
					else if (strcmp(stack[1]->name, "updated_at") == 0 && v.type == v.STR && !(pi.status.flags & pi.status.HAS_UPDATED_TIME)) {
						pi.status.flags |= pi.status.HAS_UPDATED_TIME;
						pi.updated_time = process_datetime(v.str_val);
					}
					else if (strcmp(stack[1]->name, "est_delivery_date") == 0 && v.type == v.STR) {
						pi.status.flags |= pi.status.HAS_EST_DEILIVERY;
						pi.estimated_delivery = process_datetime(v.str_val);
					}
				}
				else if (stack_ptr >= 3 && strcmp(stack[1]->name, "tracking_details") == 0 && stack[1]->is_array()) {
					parcel_entry_lengths[i] = stack[1]->index + 1;
					if (last_index != stack[1]->index) {
						last_index = stack[1]->index;
						last_seen_location.~LocationBuf();
						new (&last_seen_location) LocationBuf{};
					}
					// Grab the latest message
					if (strcmp(stack[2]->name, "message") == 0 && v.type == v.STR) {
						if (last_seen_status_line) free(last_seen_status_line);
						pi.status.flags |= pi.status.HAS_STATUS;
						last_seen_status_line = strdup(v.str_val);
						parcel_entry_text_lens[i] += strlen(v.str_val);
					}
					else if (strcmp(stack[2]->name, "status") == 0 && v.type == v.STR && strcmp(v.str_val, "unknown")) {
						pi.status_icon = get_icon_enum(v.str_val);
					}
					else if (strcmp(stack[2]->name, "datetime") == 0 && v.type == v.STR) {
						pi.status.flags |= pi.status.HAS_UPDATED_TIME;
						pi.updated_time = process_datetime(v.str_val);
					}

					// process location: 
					else if (stack_ptr == 4 && strcmp(stack[2]->name, "tracking_location") == 0) {
						if (strcmp(stack[3]->name, "city") == 0 && v.type == v.STR) {
							last_seen_location.push_city(v.str_val);
						}
						else if (strcmp(stack[3]->name, "country") == 0 && v.type == v.STR) {
							last_seen_location.push_country(v.str_val);
						}
					}
				}
			});

			if (!p_parser.parse(dw)) {
				ESP_LOGD(TAG, "json parse failed");
				encountered_error = true;
				continue;
			}

			// parse finished: fill in offsets
			if (last_seen_location) {
				pi.status.location_offset = append_shortheap(last_seen_location.get());
				pi.status.flags |= pi.status.HAS_LOCATION;
			}
			if (last_seen_status_line) {
				pi.status.status_offset = append_shortheap(last_seen_status_line);
				free(last_seen_status_line);
				pi.status.flags |= pi.status.HAS_STATUS;
			}

			parcel_oks[i] = true;
		}

		sccfg::set_force_disable_screen(slots::ScCfgInfo::PARCELS, n_parcels == 0);

		if (!n_parcels) {
			serial::interface.delete_slot(slots::PARCEL_INFOS);
			serial::interface.delete_slot(slots::PARCEL_EXTRA_INFOS);
			serial::interface.delete_slot(slots::PARCEL_STATUS_SHORT);
			serial::interface.delete_slot(slots::PARCEL_STATUS_LONG);

			dwhttp::close_connection(true);
			return true;
		}

		serial::interface.update_slot_raw(slots::PARCEL_INFOS, &pis, sizeof(slots::ParcelInfo) * n_parcels);
		append_shortheap(nullptr); // truncate

		// now, begin parsing the extended info by re-requesting all the packages
		i = -1;
		int j = -1;

		int n_extras = 0;

		for (const auto& cfg : tracker_configs) {
			++i;
			if (!parcel_oks[i]) continue;
			++j;
			// get url
			snprintf(url.get(), 128, "/v2/trackers/%s", cfg.tracker_id.get());
			auto dw = dwhttp::download_with_callback("_api.easypost.com", url.get(), headers);
			dw.make_nonclose();

			if (!dw.ok()) {
				encountered_error = true;
			}
			
			// compute how many we're going to take
			size_t entry_count = (parcel_entry_text_lens[i] > max_single_entry_textcount ? (
				    /* assume roughly equal distribution */ (parcel_entry_lengths[i] * max_single_entry_textcount) / parcel_entry_text_lens[i]) :
				    /* take all */                          parcel_entry_lengths[i] - 1);

			if (entry_count <= 1) continue;

			int entry_start_idx = parcel_entry_lengths[i] - entry_count - 1;

			ESP_LOGD(TAG, "parcel: ec %d, esi %d, tl %d, el %d", entry_count, entry_start_idx, parcel_entry_text_lens[i], parcel_entry_lengths[i]);

			slots::ParcelInfo &pi = pis[j];
			if (entry_count != parcel_entry_lengths[i]-1) pi.status.flags |= pi.status.EXTRA_INFO_TRUNCATED;
			LocationBuf last_seen_location{};

			// extrainfo buffer
			slots::ExtraParcelInfoEntry * extra_infos = new slots::ExtraParcelInfoEntry[entry_count]{};

			json::JSONParser p_parser([&](json::PathNode ** stack, uint8_t stack_ptr, const json::Value& v){
				if (stack_ptr >= 2 && strcmp(stack[1]->name, "tracking_details") == 0 && stack[1]->is_array() && stack[1]->index >= entry_start_idx && stack[1]->index < parcel_entry_lengths[i]-1) {
					slots::ExtraParcelInfoEntry &pie = extra_infos[stack[1]->index - entry_start_idx];
					if (stack_ptr >= 3) {
						// Grab the latest message
						if (strcmp(stack[2]->name, "message") == 0 && v.type == v.STR) {
							// Append
							pie.status.status_offset = append_longheap(v.str_val);
							pie.status.flags |= pie.status.HAS_STATUS;
						}
						else if (strcmp(stack[2]->name, "datetime") == 0 && v.type == v.STR) {
							pie.updated_time = process_datetime(v.str_val);
							pie.status.flags |= pie.status.HAS_UPDATED_TIME;
						}

						// process location: 
						else if (stack_ptr == 4 && strcmp(stack[2]->name, "tracking_location") == 0) {
							if (strcmp(stack[3]->name, "city") == 0 && v.type == v.STR) {
								last_seen_location.push_city(v.str_val);
							}
							else if (strcmp(stack[3]->name, "country") == 0 && v.type == v.STR) {
								last_seen_location.push_country(v.str_val);
							}
						}
					}
					else {
						// fill in entry parcel_for & location
						pie.for_parcel = j;

						if (last_seen_location) {
							pie.status.location_offset = append_longheap(last_seen_location.get());
							pie.status.flags |= pie.status.HAS_LOCATION;
						}

						// reset locationbuf
						last_seen_location.~LocationBuf();
						new (&last_seen_location) LocationBuf{};
					}
				}
			});

			if (!p_parser.parse(dw)) {
				delete[] extra_infos;
				encountered_error = true;
				continue;
			}

			// reverse order
			std::reverse(extra_infos, extra_infos + entry_count);

			// Append to big array
			serial::interface.allocate_slot_size(slots::PARCEL_EXTRA_INFOS, (n_extras + entry_count) * sizeof(slots::ExtraParcelInfoEntry));
			serial::interface.update_slot_range(slots::PARCEL_EXTRA_INFOS, extra_infos, n_extras, entry_count, true, false);

			n_extras += entry_count;

			delete[] extra_infos;
		}

		serial::interface.update_slot_raw(slots::PARCEL_INFOS, &pis, sizeof(slots::ParcelInfo) * n_parcels);
		serial::interface.trigger_slot_update(slots::PARCEL_EXTRA_INFOS);
		append_longheap(nullptr); // truncate

		dwhttp::close_connection(true);

		return !encountered_error;
	}
}
