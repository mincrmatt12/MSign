#!/usr/bin/env python3
import sys
import freetype
import string
import math
import os.path

CHARS = string.ascii_letters + string.digits + string.punctuation + 'Â°'
CHAR_NUMS = [ord(x) for x in CHARS]

if len(sys.argv) != 3:
    print("Usage: {} [font file] [font size in pixels]".format(sys.argv[0]))
    print("or   : {} [font name] h[font size in pixels]".format(sys.argv[0]))
    exit()
elif sys.argv[2][0] != "h":
    _, face_name, size_pixels = sys.argv
    size_pixels = int(size_pixels)
else:
    _, face_name, size_pixels = sys.argv
    size_pixels = int(size_pixels[1:])
    font_simple_name = os.path.splitext(os.path.basename(face_name))[0].replace("-", "_").replace(" ", "_").strip(string.digits + string.whitespace + "./\"'!@#$%^&*()[]{};,.").lower() + "_" + str(size_pixels)
    header_name = "FONT_" + font_simple_name.upper() + "_H"
    # create a stupid header
    print(f"#ifndef {header_name}\n#define {header_name}")
    print()
    print(f"namespace font::{font_simple_name} {{")
    print("extern const void * const info[4]; // metrics, data, pointer to kern_size, kerning")
    print("}")
    print()
    print("// generated by fnter w/ {}".format(face_name))
    print()
    print("#endif")

    exit(0)


face = freetype.Face(face_name)
face.set_pixel_sizes(0, size_pixels)

def get_character_as_bool_array(c):
    global face

    face.load_char(c, freetype.FT_LOAD_RENDER | freetype.FT_LOAD_TARGET_MONO)

    bitmap = face.glyph.bitmap

    result = []
    res2   = []
    for i in range(0, bitmap.rows * bitmap.pitch, bitmap.pitch):
        arr = []
        seen = []
        arr2 = []
        for j in range(bitmap.width):
            byte, bit = divmod(j, 8)
            bit = 7 - bit
            if byte not in seen:
                seen.append(byte)
                arr2.append(bitmap.buffer[i+byte])
            arr.append(bitmap.buffer[i+byte] & (1 << bit) != 0)
        result.append(arr)
        res2.append(arr2)
    
    return result, res2

def get_metrics(c):
    global face

    face.load_char(c, freetype.FT_LOAD_TARGET_MONO)
    return [
            int(face.glyph.metrics.horiAdvance / 64.0),
            int(face.glyph.metrics.horiBearingX / 64.0),
            int(face.glyph.metrics.horiBearingY / 64.0)
    ]

def round_away_from_zero(x):
    a = abs(x)
    r = math.floor(a) + math.floor(2 * (a % 1))
    return r if x >= 0 else -r

def calc_kerning(c):
    global face
    
    entries = []
    for other in sorted(CHAR_NUMS):
        kerning = face.get_kerning(c, chr(other))
        pix = int(round_away_from_zero(kerning.x / 64))
        if pix == 0:
            continue
        else:
            entries.append((ord(c), other, pix))
    return entries


font_simple_name = os.path.splitext(os.path.basename(face_name))[0].replace("-", "_").replace(" ", "_").strip(string.digits + string.whitespace + "./\"'!@#$%^&*()[]{};,.").lower() + "_" + str(size_pixels)
header_name = "FONT_" + font_simple_name.upper() + "_H"

print("#include <stdint.h>")
print()
print(f"namespace font::{font_simple_name} {{")
print(f"namespace {{")

metrics = {}

# generate the data arrays
for i in range(256):
    if i in CHAR_NUMS:
        img, dat = get_character_as_bool_array(chr(i))
        metrics[i] = len(img[0]), len(img), int(math.ceil(len(img[0]) / 8))
        print("const uint8_t data_{}[] = {{".format(i))
        zipped = [(", ".join(str(u) for u in x), "".join("#" if z else " " for z in y)) for x, y in zip(dat, img)]
        padding = (5 * metrics[i][2]) + 1
        for i in zipped:
            print(("\t{:<" + str(padding) + "} // {}").format(i[0] + ",", i[1]))
        print("};")
        print()

print("}")

print("const int16_t metrics[][6] = { // width, height, n_bytes, advance, bearingX, bearingY")
for i in range(256):
    if i not in metrics:
        print("\t{0, 0, 0, 0, 0, 0}, // no char here")
        continue
    j = list(metrics[i])
    j.extend(get_metrics(chr(i)))
    j = [str(x) for x in j]
    print("\t{{ {} }}, // {}  ".format(", ".join(j), chr(i) if chr(i) != "\\" else "backslash"))
print("};")

print("const uint8_t * const data[] = {")
for i in range(256):
    if i not in metrics:
        print("\tnullptr,")
        continue
    print("\tdata_{},".format(i))

print("};")

table = []
if face.has_kerning:
    for i in sorted(CHAR_NUMS):
        table.extend(calc_kerning(chr(i)))

if table:
    print("// kerning table has {} entries".format(len(table)))
    print("const uint32_t kerning_size = {};".format(len(table)))
    print()
    print("const int16_t kerning[][3] = {")
    for i in table:
        a = chr(i[0])
        b = chr(i[1]) if i[1] != ord("\\") else "backslash"
        print("\t{{ {} }}, // {} + {} -> {} ".format(", ".join(str(x) for x in i), a, b, i[2]))
    print("};")

    print("extern const void * const info[] = { // metrics, data, pointer to kern_size, kerning")
    print("\tmetrics,\n\tdata,\n\t&kerning_size,\n\tkerning\n};")
else:
    print("// no kerning data available")
    print("extern const void * const info[] = { // metrics, data, pointer to kern_size, kerning")
    print("\tmetrics,\n\tdata,\n\tnullptr,\n\tnullptr\n};")
    

print("}")
print()
print("// generated by fnter w/ {} {}".format(face_name, size_pixels))
print()
